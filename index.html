<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="好人生科技有限公司，主职iOS开发，和H5开发的软件开发工程师">
<meta name="keywords" content="iOS, HTML5, 运动, 生活">
<meta property="og:type" content="website">
<meta property="og:title" content="Mdiep">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Mdiep">
<meta property="og:description" content="好人生科技有限公司，主职iOS开发，和H5开发的软件开发工程师">
<meta property="og:locale" content="zh">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Mdiep">
<meta name="twitter:description" content="好人生科技有限公司，主职iOS开发，和H5开发的软件开发工程师">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>Mdiep</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Mdiep</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">编程就像搭积木</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/15/blog-6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="mdiep">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mdiep">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/15/blog-6/" itemprop="url">WKWebView相比于UIWebView浏览器之间内核引擎的区别</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-04-15T11:10:44+08:00">
                2018-04-15
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS/" itemprop="url" rel="index">
                    <span itemprop="name">iOS</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS/WebView/" itemprop="url" rel="index">
                    <span itemprop="name">WebView</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/04/15/blog-6/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2018/04/15/blog-6/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="WKWebView相比于UIWebView浏览器之间内核引擎的区别"><a href="#WKWebView相比于UIWebView浏览器之间内核引擎的区别" class="headerlink" title="WKWebView相比于UIWebView浏览器之间内核引擎的区别"></a>WKWebView相比于UIWebView浏览器之间内核引擎的区别</h1><p>翻译文，原文地址</p>
<p><a href="https://docs.kioskproapp.com/article/840-wkwebview-supported-features-known-issues" target="_blank" rel="noopener">WKWebView: Differences from UIWebView browsing engine</a></p>
<blockquote>
<p><strong>优点</strong></p>
<p>多进程，在app的主进程之外执行</p>
<p>使用更快的Nitro JavaScript引擎</p>
<p>异步执行处理JavaScript</p>
<p>消除某些触摸延迟</p>
<p>支持服务端的身份校验</p>
<p>支持对错误的自签名安全证书和证书进行身份验证</p>
</blockquote>
<p>-</p>
<blockquote>
<p><strong>问题</strong></p>
<p>需要iOS9或更高版本(WKWebView在iOS8引入，但是很多功能，支持比较全面在iOS9以后的版本)</p>
<p>不支持通过AJAX请求本地存储的文件</p>
<p>不支持”Accept Cookies”的设置</p>
<p>不支持”Advanced Cache Settings”(高级缓存设置)</p>
<p>App退出会清除HTML5的本地存储的数据</p>
<p>不支持记录WebKit的请求</p>
<p>不能进行截屏操作</p>
</blockquote>
<h2 id="优点-Advantages"><a href="#优点-Advantages" class="headerlink" title="优点(Advantages)"></a>优点(Advantages)</h2><h3 id="多进程，在app的主进程之外执行"><a href="#多进程，在app的主进程之外执行" class="headerlink" title="多进程，在app的主进程之外执行"></a>多进程，在app的主进程之外执行</h3><p>WKWebView为多进程组件，也意味着会从App内存中分离内存到单独的进程(Network Process and Rendring Process)中。当内存超过了系统分配给WKWebView的内存时候，会导致WKWebView浏览器崩溃白屏，但是App不会Crash。(app会收到系统通知，并且尝试去重新加载页面)</p>
<p>相反的，UIWebView是和app同一个进程，UIWebView加载页面占用的内存被计算为app内存占用的一部分，当app超过了系统分配的内存，则会被操作系统crash。在整个过程中，会经常收到iOS系统的通知用来防止app被系统kill，但是在某些时候，这些通知不够及时，或者根本没有返回通知。</p>
<h3 id="使用更快的Nitro-JavaScript引擎"><a href="#使用更快的Nitro-JavaScript引擎" class="headerlink" title="使用更快的Nitro JavaScript引擎"></a>使用更快的Nitro JavaScript引擎</h3><p>WKWebView使用和手机Safari浏览器一样的Nitro JavaScript引擎，相比于UIWebView的JavaScript引擎有了非常重要的性能提升</p>
<h3 id="异步执行处理JavaScript"><a href="#异步执行处理JavaScript" class="headerlink" title="异步执行处理JavaScript"></a>异步执行处理JavaScript</h3><p>WKWebView是异步处理app原生代码与JavaScript之间的通信，因此普遍上执行速度会更快。</p>
<p>在实践操作过程中，JavaScript API调用原生(native)中方法不会阻塞线程，等待回调函数的执行。(在JavaScript代码会继续向下执行，而回调函数会由native端异步去回调)。举一个例子，之前一个”Save Data”的操作如下:</p>
<pre><code>// JavaScript code - 笔者注
// 注释 - 笔者注

var filenameID;
function getFilenameID() {
    // 向native端发起请求，获取kioskId，结果返回由callback方式返回 
    window.kp_requestKioskId(&quot;kp_requestKioskId_callback&quot;);
}
// callback回调函数 - 由native端发起 
function kp_requestKioskId_callback(kioskId) {
    filenameID = kioskId.split(&quot; &quot;).join(&quot;&quot;);
}
// kp_FileAPI_writeToFile方法不会等待kp_requestKioskId_callback回调函数执行，此时filenameID为undefined
function saveData(fileName, data) {
    getFilenameID();
    kp_FileAPI_writeToFile(filenameID + &quot;.xls&quot;, data, &quot;writeFile_callback&quot;);
}
</code></pre><p>原先的假定是在’saveData’方法被触发时，在’kp_FileAPI_writeToFile’方法调用前，’getFilenameID’方法会返回filenameID</p>
<p>但是，在WKWebView中JavaScript和native代码之间的通信是异步的，’kp_FileAPI_writeToFile’方法被调用之前，’getFilenameID’方法还没有完成(回调还没有被执行-笔者注)，导致的结果是在’kp_FileAPI_writeToFile’中filename为undefined。为了正确的得到filename，必须重构之前的代码，在callback中完成。如下：</p>
<pre><code>var filenameID;
function getFilenameID() {
    window.kp_requestKioskId(&quot;kp_requestKioskId_callback&quot;);
}
function kp_requestKioskId_callback(kioskId) {
    filenameID = kioskId.split(&quot; &quot;).join(&quot;&quot;);
    kp_FileAPI_writeToFile(filenameID + &quot;.xls&quot;, data, &quot;writeFile_callback&quot;);
}
function saveData(fileName, data) {
    getFilenameID();
}
</code></pre><h3 id="消除触摸延迟"><a href="#消除触摸延迟" class="headerlink" title="消除触摸延迟"></a>消除触摸延迟</h3><p>UIWebView和WKWebView浏览器组件会将触摸事件解释后发送给app，因此，我们无法提高触摸事件的灵敏度或速度。</p>
<p>在UIWebView上的任何触摸事件会被<a href="https://www.telerik.com/blogs/what-exactly-is.....-the-300ms-click-delay" target="_blank" rel="noopener">延迟300ms</a>，用以判断用户是单击还是双击。这个机制也是那些基于HTML的web app一直不被用户接受的重要原因。</p>
<p>在WKWebView中，测试显示，只有在点击很快(&lt;~125ms)的时候才会添加300ms的延迟，iOS将其解释为更可能是双击“点击缩放”手势的一部分，而不是慢点击（&gt;〜125 ms）后。更多细节在<a href="http://developer.telerik.com/featured/300-ms-click-delay-ios-8/" target="_blank" rel="noopener">这里</a></p>
<p>为了消除所有触摸事件（包括快速点击）的触摸延迟，您可以添加<a href="https://github.com/ftlabs/fastclick" target="_blank" rel="noopener">FastClick</a>或另一个消除此延迟的库到您的内容中。</p>
<h3 id="支持服务端的身份校验"><a href="#支持服务端的身份校验" class="headerlink" title="支持服务端的身份校验"></a>支持服务端的身份校验</h3><p>与不支持服务器认证校验的UIWebView不同，WKWebView支持服务端校验。实际上，这意味着在使用WKWebView时，可以输入密码保护网站。</p>
<h3 id="支持对错误的自签名安全证书和证书进行身份验证"><a href="#支持对错误的自签名安全证书和证书进行身份验证" class="headerlink" title="支持对错误的自签名安全证书和证书进行身份验证"></a>支持对错误的自签名安全证书和证书进行身份验证</h3><p>通过“继续”/“取消”弹出窗口，WKWebView允许您绕过安全证书中的错误（例如，使用自签名证书或过期证书时）。</p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><h3 id="需要iOS9或更高版本"><a href="#需要iOS9或更高版本" class="headerlink" title="需要iOS9或更高版本"></a>需要iOS9或更高版本</h3><p>我们的WKWebView集成仅适用于运行iOS 9或更高版本的设备。虽然WKWebView是在iOS 8中引入的，但在这些版本中存在重大限制，包括无法访问本地存储的文件，我们无法解决此问题，因此此功能不兼容。</p>
<p>###不支持AJAX请求到本地存储的文件</p>
<p>WKWebView不允许XHR请求file：// URI，因为这些URI违反了浏览器引擎的跨源资源共享规则。使用这种类型的请求的项目应该远程托管在服务器上，或使用现有的UIWebView浏览引擎。</p>
<h3 id="不支持”Accept-Cookies”的设置"><a href="#不支持”Accept-Cookies”的设置" class="headerlink" title="不支持”Accept Cookies”的设置"></a>不支持”Accept Cookies”的设置</h3><p>虽然WKWebView确实支持使用cookies，但并没有公开选择哪些cookies被源代码接受的能力。这意味着在使用WKWebView浏览引擎时不会应用“接受Cookie”设置。</p>
<p>WKWebView只允许我们访问cookie的名称，而不是附加信息，如创建/过期日期或路径，这使得更难以解决Cookie出现的问题。</p>
<h3 id="不支持”Advanced-Cache-Settings”-高级缓存设置"><a href="#不支持”Advanced-Cache-Settings”-高级缓存设置" class="headerlink" title="不支持”Advanced Cache Settings”(高级缓存设置)"></a>不支持”Advanced Cache Settings”(高级缓存设置)</h3><p>使用WKWebView浏览引擎时，不会应用“缓存源”和“仅通知服务器重定向事件的浏览器”。</p>
<h3 id="App退出会清除HTML5的本地存储的数据"><a href="#App退出会清除HTML5的本地存储的数据" class="headerlink" title="App退出会清除HTML5的本地存储的数据"></a>App退出会清除HTML5的本地存储的数据</h3><p>当应用退出并重新启动时，HTML5本地存储将被清除。</p>
<h3 id="不支持记录WebKit的请求"><a href="#不支持记录WebKit的请求" class="headerlink" title="不支持记录WebKit的请求"></a>不支持记录WebKit的请求</h3><p>WKWebView发出请求并呈现内容，无法直接访问此类请求，并且无法记录这些请求。</p>
<h3 id="不能进行截屏操作"><a href="#不能进行截屏操作" class="headerlink" title="不能进行截屏操作"></a>不能进行截屏操作</h3><p>尽管我们在测试中没有看到使用Kiosk Pro的JavaScript API进行屏幕捕获的任何问题，但其他iOS开发人员报告说屏幕捕获在WKWebView上随机失败。如果截屏的API是app中的关键操作，建议使用现有的UIWebView浏览引擎。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/12/blog-5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="mdiep">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mdiep">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/12/blog-5/" itemprop="url">用 CSS 实现元素垂直居中</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-04-12T10:24:56+08:00">
                2018-04-12
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/HTML/" itemprop="url" rel="index">
                    <span itemprop="name">HTML</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/HTML/JavaScript/" itemprop="url" rel="index">
                    <span itemprop="name">JavaScript</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/04/12/blog-5/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2018/04/12/blog-5/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="水平居中设置"><a href="#水平居中设置" class="headerlink" title="水平居中设置"></a>水平居中设置</h3><p>1、行内元素<br>设置 text-align:center</p>
<p>2、定宽块状元素<br>设置 左右 margin 值为 auto</p>
<p>3、不定宽块状元素<br>a:在元素外加入 table 标签（完整的，包括 table、tbody、tr、td），该元素写在 td 内，然后设置 margin 的值为 auto<br>b:给该元素设置 displa:inine 方法<br>c:父元素设置 position:relative 和 left:50%，子元素设置 position:relative 和 left:50%</p>
<h3 id="垂直居中设置"><a href="#垂直居中设置" class="headerlink" title="垂直居中设置"></a>垂直居中设置</h3><p>1、父元素高度确定的单行文本<br>设置 height = line-height</p>
<p>2、父元素高度确定的多行文本<br>a:插入 table （插入方法和水平居中一样），然后设置 vertical-align:middle<br>b:先设置 display:table-cell 再设置 vertical-align:middle</p>
<p>在前端面试中，大都会问你div居中的方法：</p>
<p>不过以后文笔肯定会变得更好一些的。</p>
<p>开始这些东西之前也可以测试一下你对<a href="https://link.zhihu.com/?target=http%3A//v.youku.com/v_show/id_XMTM2MDQ2MTM2OA%3D%3D.html" target="_blank" rel="noopener">html</a>了解多少，让我们测试一下吧，<a href="https://link.zhihu.com/?target=http%3A//mp.weixin.qq.com/s%3F__biz%3DMzI0NDAzOTYxMw%3D%3D%26mid%3D402309487%26idx%3D1%26sn%3Dc8b4c5298f27a9c47362fda1f9e21b12%23rd" target="_blank" rel="noopener">小测验：你对HTML5了解有多少？</a></p>
<p><strong>今天就细数一下几种方法：</strong></p>
<p>1，使用position:absolute,设置left、top、margin-left、margin-top的属性</p>
<pre><code>.one{
      position:absolute;
      width:200px;
      height:200px;
      top:50%;
      left:50%;
      margin-top:-100px;
      margin-left:-100px;
      background:red;
}
</code></pre><p>这种方法基本浏览器都能够兼容，不足之处就是需要固定宽高。</p>
<p>2，使用position:fixed,同样设置left、top、margin-left、margin-top的属性</p>
<pre><code>.two{
    position:fixed;
    width:180px;
    height:180px;
    top:50%;
    left:50%;
    margin-top:-90px;
    margin-left:-90px;
    background:orange;
 }
</code></pre><p>大家都知道的position:fixed,IE是不支持这个属性的</p>
<p>3，利用position:fixed属性，margin:auto这个必须不要忘记了。</p>
<pre><code> .three{
      position:fixed;
      width:160px;
      height:160px;
      top:0;
      right:0;
      bottom:0;
      left:0;
      margin:auto;
      background:pink;
}
</code></pre><p>4，利用position:absolute属性，设置top/bottom/right/left</p>
<pre><code>.four{
    position:absolute;
    width:140px;
    height:140px;
    top:0;
    right:0;
    bottom:0;
    left:0;
    margin:auto;
    background:black;
}
</code></pre><p>5，利用display:table-cell属性使内容垂直居中</p>
<pre><code>.five{
    display:table-cell;
    vertical-align:middle;
    text-align:center;
    width:120px;
    height:120px;
    background:purple;
}
</code></pre><p>6，最简单的一种使行内元素居中的方法，使用line-height属性</p>
<pre><code>.six{
    width:100px;
    height:100px;
    line-height:100px;
    text-align:center;
    background:gray;
}
</code></pre><p>这种方法也很实用，比如使文字垂直居中对齐</p>
<p>7，使用css3的display:-webkit-box属性，再设置-webkit-box-pack:center/-webkit-box-align:center</p>
<pre><code>.seven{
    width:90px;
    height:90px;
    display:-webkit-box;
    -webkit-box-pack:center;
    -webkit-box-align:center;
    background:yellow;
    color:black;
 }
</code></pre><p>8，使用css3的新属性transform:translate(x,y)属性</p>
<pre><code> .eight{
     position:absolute;
    width:80px;
    height:80px;
  top:50%;
  left:50%;
  transform:translate(-50%,-50%);
  -webkit-transform:translate(-50%,-50%);
  -moz-transform:translate(-50%,-50%);
  -ms-transform:translate(-50%,-50%);
  background:green;
}
</code></pre><p><strong>这个方法可以不需要设定固定的宽高，在移动端用的会比较多，在移动端css3兼容的比较好</strong></p>
<p>9、最高大上的一种，使用:before元素</p>
<pre><code>.nine{
    position:fixed;
    display:block;
    top:0;
    right:0;
    bottom:0;
    left:0;
    text-align:center;
    background:rgba(0,0,0,.5);
}
.nine:before{
    content:&apos;&apos;;
    display:inline-block;
    vertical-align:middle;
    height:100%;
}
 .nine .content{
    display:inline-block;
    vertical-align:middle;
    width:60px;
    height:60px;
    line-height:60px;
    color:red;
    background:yellow;
}
</code></pre><p>总而言之所有的居中的方法就是你必须要掌握css属性的这个概念<a href="https://link.zhihu.com/?target=http%3A//mp.weixin.qq.com/s%3F__biz%3DMzI0NDAzOTYxMw%3D%3D%26mid%3D402255125%26idx%3D3%26sn%3Df13ca64eb1bcc4bf31aefdc189ccc26b%23rd" target="_blank" rel="noopener">HTML DIV+CSS</a> ，你掌握了就可以好好的运用这些居中的东西了</p>
<p>参考：知乎<a href="https://www.zhihu.com/question/20543196" target="_blank" rel="noopener">用 CSS 实现元素垂直居中，有哪些好的方案？</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/12/blog-4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="mdiep">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mdiep">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/12/blog-4/" itemprop="url">iOS 并发编程 - Operation And NSOperation Queue</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-04-12T10:20:12+08:00">
                2018-04-12
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS/" itemprop="url" rel="index">
                    <span itemprop="name">iOS</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS/多线程/" itemprop="url" rel="index">
                    <span itemprop="name">多线程</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/04/12/blog-4/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2018/04/12/blog-4/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ul>
<li><p>基本概念</p>
<ol>
<li>术语</li>
<li>串行 vs 并发(concurrency)</li>
<li>同步 vs 异步</li>
<li>队列 vs 线程</li>
</ol>
</li>
<li><p>iOS的并发编程模型</p>
</li>
<li><p>Operation Queues vs. Grand Central Dispatch (GCD)</p>
</li>
<li><p>关于Operation对象</p>
<ol>
<li>并发的Operation 和非并发的Operation</li>
<li>创建NSBlockOperation对象 </li>
<li>创建NSInvocationOperation对象</li>
</ol>
</li>
<li><p>自定义Operation对象</p>
<ol>
<li>自定义的非并发NSOperation－不实现取消操作</li>
<li>自定义的非并发NSOperation－实现取消操作</li>
</ol>
</li>
<li><p>定制Operation对象的执行行为</p>
<ol>
<li>修改Operation在队列中的优先级</li>
<li>修改Operation执行任务线程的优先级</li>
<li>设置Completion Block</li>
</ol>
</li>
<li><p>执行Operation对象</p>
<ol>
<li>添加Operation到Operation Queue中</li>
<li>手动执行Operation</li>
<li>取消Operation</li>
<li>等待Operation执行完成</li>
<li>暂停和恢复Operation Queue</li>
</ol>
</li>
<li><p>添加Operation Queue中Operation对象之间的依赖</p>
</li>
<li><p>总结</p>
</li>
</ul>
<hr>
<p>看过上面的结构预览，下面就开始我们这篇blog</p>
<h2 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h2><blockquote>
<p>Operation: The NSOperation class is an abstract class you use to encapsulate the code and data associated with a single task.</p>
</blockquote>
<p>解释：Operation是一个抽象类。你可以通过组织一段代码和数据，表示一个任务。</p>
<blockquote>
<p>Operation Queue: The NSOperationQueue class regulates the execution of a set of NSOperation objects.</p>
</blockquote>
<p>解释： NSOperationQueue用于规则的去执行一系列Operation。<br>任务：通常的说是由一段代码和数据组成，可以完成特定某项功能的代码数据集合。<br>进程：进程可以理解CPU所能执行的单个任务，CPU任何一个时刻职能运行一个进程。<br>线程：线程是计算机CPU所能执行最小单元，亦可以理解简化版的进程。一个进程可以包含多个线程。</p>
<h2 id="串行-vs-并发"><a href="#串行-vs-并发" class="headerlink" title="串行 vs 并发"></a>串行 vs 并发</h2><p>最简单的理解就是，串行和并发是用来修饰是否可以同时执行任务的数量的。串行设计只允许同一个时间段中只能一个任务在执行。并发设计在同一个时间段中，允许多个任务在逻辑上交织进行。(在iOS中，串行和并发一般用于描述队列)<br><strong>说个题外话，刚开始是将并发写成并行的，后觉得并发和并行的概念一直挥之不去，可以参考这篇，很赞奥——<a href="https://laike9m.com/blog/huan-zai-yi-huo-bing-fa-he-bing-xing,61/" target="_blank" rel="noopener">还在疑惑并发和并行？</a></strong></p>
<h2 id="同步-vs-异步"><a href="#同步-vs-异步" class="headerlink" title="同步 vs 异步"></a>同步 vs 异步</h2><p>同步操作，只有当该操作执行完成返回后，才能执行其他代码，会出现等待，易造成线程阻塞。异步操作，不需要等到当前操作执行完，就可以返回，执行其他代码。(一般用于描述线程)</p>
<h2 id="队列-vs-线程"><a href="#队列-vs-线程" class="headerlink" title="队列 vs 线程"></a>队列 vs 线程</h2><p>队列用于存放Operation。在iOS中，队列分为串行队列和并发队列。使用NSOperationQueue时，我们不需要自己创建去创建线程，我们只需要自己去创建我们的任务(Operation)，将Operation放到队列中去。队列会负责去创建线程执行，执行完后，会销毁释放线程占用的资源。</p>
<hr>
<h2 id="iOS并发编程模型"><a href="#iOS并发编程模型" class="headerlink" title="iOS并发编程模型"></a>iOS并发编程模型</h2><p>对于一个APP，需要提高应用的性能，一般需要创建辅助的线程去执行任务。在整个APP的生命周期内，我们需要自己手动去创建，销毁线程，以及暂停，开启线程。对于这创建一个这样的线程管理方案，已经是非常复杂且艰巨的任务。但是苹果爸爸为开发者提供了两套更好的解决方案：<strong><a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/NSOperation_class/" target="_blank" rel="noopener">NSOperation</a></strong>，<strong><a href="https://developer.apple.com/library/ios/documentation/Performance/Reference/GCD_libdispatch_Ref/" target="_blank" rel="noopener">Grand Central Dispatch (GCD) Reference</a></strong>，GCD的方式具体的本文暂不讨论。</p>
<p>使用NSOperationQueue 和 NSOperation的方式是苹果基于GCD再一次封装的一层，比GCD更加的灵活，而且是一种面向对象设计，更加适合开发人员。虽然相对于GCD会牺牲一些性能，但是我们可以对线程进行更多的操作，比如暂停，取消，添加Operation间的依赖。但是GCD如果暂停和取消线程操作则十分的麻烦。</p>
<h2 id="Operation-Queues-vs-Grand-Central-Dispatch-GCD"><a href="#Operation-Queues-vs-Grand-Central-Dispatch-GCD" class="headerlink" title="Operation Queues vs. Grand Central Dispatch (GCD)"></a>Operation Queues vs. Grand Central Dispatch (GCD)</h2><blockquote>
<p>简单来说，GCD 是苹果基于 C 语言开发的，一个用于多核编程的解决方案，主要用于优化应用程序以支持多核处理器以及其他对称多处理系统。而 Operation Queues 则是一个建立在 GCD 的基础之上的，面向对象的解决方案。它使用起来比 GCD 更加灵活，功能也更加强大。下面简单地介绍了 Operation Queues 和 GCD 各自的使用场景：</p>
</blockquote>
<blockquote>
<p>Operation Queues ：相对 GCD 来说，使用 Operation Queues 会增加一点点额外的开销，但是我们却换来了非常强大的灵活性和功能，我们可以给 operation 之间添加依赖关系、取消一个正在执行的 operation 、暂停和恢复 operation queue 等；<br>GCD ：则是一种更轻量级的，以 FIFO 的顺序执行并发任务的方式，使用 GCD 时我们并不关心任务的 调度情况，而让系统帮我们自动处理。但是 GCD 的短板也是非常明显的，比如我们想要给任务之间添加依赖关系、取消或者暂停一个正在执行的任务时就会变得非常棘手。</p>
</blockquote>
<p><strong>上引用自<a href="http://blog.leichunfeng.com/blog/2015/07/29/ios-concurrency-programming-operation-queues/" target="_blank" rel="noopener">Operation Queues vs. Grand Central Dispatch (GCD)</a></strong></p>
<h2 id="关于Operation对象"><a href="#关于Operation对象" class="headerlink" title="关于Operation对象"></a>关于Operation对象</h2><p><code>NSOperation</code>对象是一个抽象类，是不能直接创建对象的。但是它有两个子类——<code>NSBlockOperation</code>，<code>NSInvocationOperation</code>.通常情况下我们都可以直接使用这两个子类，创建可以并发的任务。</p>
<p>我们查看关于NSOperation.h的头文件，可以发现任意的operation对象都可以自行开始任务(start)，取消任务(cancle)，以及添加依赖(addDependency:)和移除依赖(removeDependency:).<strong>关于依赖，有一种很好的一种开发思路</strong>。在operation对象中有很多属性，可以用于检测当前任务的状态，如<code>isCancelled</code>:是否已经取消，<code>isFinished</code>:是否已经完成了任务。<br><img src="http://upload-images.jianshu.io/upload_images/1626952-be8fe4d46ab20aa2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="屏幕快照 2016-06-07 下午8.29.04.png"></p>
<ul>
<li><strong>创建NSBlockOperation</strong></li>
</ul>
<p>以下使用到的代码片段取自我的<a href="https://github.com/beyondverage0908/MyDemo/tree/master/LSOperationAndOperationQueueDemo" target="_blank" rel="noopener">LSOperationAndOperationQueueDemo</a></p>
<p><code>NSBlockOperation</code>顾名思义，是是用block来创建任务，主要有两种方式创建，一种是是用类方法，一种是创建operation对象，再添加任务。上代码：以下代码包括了两种block创建任务的方式。以及已经有任务的operation对象再添加任务。及直接添加任务到queue中。</p>
<pre><code>@implementation LSBlockOperation

+ (LSBlockOperation *)lsBlockOperation {
    return [[LSBlockOperation alloc] init];
}

- (void)operatingLSBlockOperation {

    NSBlockOperation *blockOpt1 = [NSBlockOperation blockOperationWithBlock:^{
        NSLog(@&quot;-------- blockOpt1, mainThread:%@, currentThread:%@&quot;, [NSThread mainThread], [NSThread currentThread]);
    }];
    /// 继续添加执行的block
    [blockOpt1 addExecutionBlock:^{
        NSLog(@&quot;-------- blockOpt1 addExecutionBlock1 mainThread:%@, currentThread:%@&quot;, [NSThread mainThread], [NSThread currentThread]);
    }];

    [blockOpt1 addExecutionBlock:^{
        NSLog(@&quot;-------- blockOpt1 addExecutionBlock2 mainThread:%@, currentThread:%@&quot;, [NSThread mainThread], [NSThread currentThread]);
    }];

    NSBlockOperation *blockOpt2 = [[NSBlockOperation alloc] init];
    [blockOpt2 addExecutionBlock:^{
        NSLog(@&quot;-------- blockOpt2 mainThread:%@, currentThread:%@&quot;, [NSThread mainThread], [NSThread currentThread]);
    }];

    NSBlockOperation *blockOpt3 = [[NSBlockOperation alloc] init];
    [blockOpt3 addExecutionBlock:^{
        NSLog(@&quot;-------- blockOpt3 mainThread:%@, currentThread:%@&quot;, [NSThread mainThread], [NSThread currentThread]);
    }];

    NSBlockOperation *blockOpt4 = [NSBlockOperation blockOperationWithBlock:^{
        NSLog(@&quot;-------- blockOpt4 mainThread:%@, currentThread:%@&quot;, [NSThread mainThread], [NSThread currentThread]);
    }];

    // 添加执行优先级 - 并不能保证执行顺序
//    blockOpt2.queuePriority = NSOperationQueuePriorityVeryHigh;
//    blockOpt4.queuePriority = NSOperationQueuePriorityHigh;

    /// 可以设置Operation之间的依赖关系 - 执行顺序3 2 1 4
    [blockOpt2 addDependency:blockOpt3];
    [blockOpt1 addDependency:blockOpt2];
    [blockOpt4 addDependency:blockOpt1];

    NSOperationQueue *queue = [[NSOperationQueue alloc] init];
    [queue addOperation:blockOpt1];
    [queue addOperation:blockOpt2];
    [queue addOperation:blockOpt3];
    [queue addOperation:blockOpt4];
    [queue addOperationWithBlock:^{
        NSLog(@&quot;-------- queue addOperationWithBlock1 mainThread:%@, currentThread:%@&quot;, [NSThread mainThread], [NSThread currentThread]);
    }];
    [queue addOperationWithBlock:^{
        NSLog(@&quot;-------- queue addOperationWithBlock2 mainThread:%@, currentThread:%@&quot;, [NSThread mainThread], [NSThread currentThread]);
    }];
}
</code></pre><ul>
<li><strong>创建NSInvocationOperation</strong></li>
</ul>
<p><code>NSInvocationOperation</code>是另一种可创建的operation对象的类。但是在Swift中已经被去掉了。<code>NSInvocationOperation</code>是一种可以非常灵活的创建任务的方式，主要是其中包含了一个<code>target</code>和<code>selector</code>。假设我们现在有一个任务，已经在其它的类中写好了，为了避免代码的重复，我们可以将当前的<code>target</code>指向为那个类对象，方法选择器指定为那个方法即可，如果有参数，可以在<code>NSInvocationOperation</code>创建中指定对应的Object(参数).</p>
<p>具体的可以看如下代码：<a href="https://github.com/beyondverage0908/MyDemo/tree/master/LSOperationAndOperationQueueDemo" target="_blank" rel="noopener">LSOperationAndOperationQueueDemo</a></p>
<pre><code>@implementation LSInvocationOperation

+ (LSInvocationOperation *)lsInvocationOperation {
    return [[LSInvocationOperation alloc] init];
}

- (void)operationInvocationOperation {

    NSInvocationOperation *invoOpt1 = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(invoOperated1) object:self];
    NSInvocationOperation *invoOpt2 = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(invoOperated2) object:self];

    // invocated other obj method
    /// 可以执行其它类中方法，并且可以带参数
    NSInvocationOperation *invoOpt4 = [[NSInvocationOperation alloc] initWithTarget:[[Person alloc] init] selector:@selector(running:) object:@&quot;linsir&quot;];

    // 设置优先级 － 并不能保证按指定顺序执行
//    invoOpt1.queuePriority = NSOperationQueuePriorityVeryLow;
//    invoOpt4.queuePriority = NSOperationQueuePriorityVeryLow;
//    invoOpt2.queuePriority = NSOperationQueuePriorityHigh;

    // 设置依赖 - 线性执行
    [invoOpt1 addDependency:invoOpt2];
    [invoOpt2 addDependency:invoOpt4];

    NSOperationQueue *queue = [[NSOperationQueue alloc] init];
    [queue addOperation:invoOpt1];
    [queue addOperation:invoOpt2];
    [queue addOperation:invoOpt4];
}

- (void)invoOperated1 {
    NSLog(@&quot;--------- invoOperated1, mainThread:%@, currentThread:%@&quot;, [NSThread mainThread],[NSThread currentThread]);
}

- (void)invoOperated2 {
    NSLog(@&quot;--------- invoOperated2, mainThread:%@, currentThread:%@&quot;, [NSThread mainThread],[NSThread currentThread]);
}

@end
</code></pre><h2 id="自定义Operation对象"><a href="#自定义Operation对象" class="headerlink" title="自定义Operation对象"></a>自定义Operation对象</h2><p>上文介绍了两种系统定义的NSOperation，通常情况下，我们可以直接使用，已经可以满足了大部分的需求。但是当系统的不能满足时候，我们就需要自定义我们自己的Operation对象。Operation对象可以分为并发的和非并发的两类。从实现角度上而言，非并发的更容易实现的多。因为非并发的Operation对象中的很多属性，它的父类已经做好了管理，我们只需要直接使用就可以了。<strong>(通常情况下，实现多线程是由NSOperationQueue对象管理的，而不是NSOperation对象)</strong>实现自定义的NSOperation对象，最少需要重写两个方法，一个是初始化init方法(传值)，一个是mian方法(主要的逻辑实现)。</p>
<ul>
<li><p><strong>自定义的非并发NSOperation－不实现取消操作</strong></p>
<p>  代码片段取自<a href="https://github.com/beyondverage0908/MyDemo/tree/master/LSOperationAndOperationQueueDemo" target="_blank" rel="noopener">LSOperationAndOperationQueueDemo</a></p>
<pre><code>@interface LSNonConcurrentOperation ()

@property (nonatomic, strong)id data;

@end

/**
 自定义一个非并发的Operation，最少需要实现两个方法，一个初始化的init方法，另一个是mian方法，即主方法，逻辑的主要执行体。
 */
@implementation LSNonConcurrentOperation

- (id)initWithData:(id)data {
    self = [self init];
    if (self) {
        self.data = data;
    }
    return self;
}

// 该主方法不支持Operation的取消操作
- (void)main {
    @try {

        NSLog(@&quot;-------- LSNonConcurrentOperation - data:%@, mainThread:%@, currentThread:%@&quot;, self.data, [NSThread mainThread], [NSThread currentThread]);
        sleep(2);
        NSLog(@&quot;-------- finish executed %@&quot;, NSStringFromSelector(_cmd));

    } @catch (NSException *exception) {

        NSLog(@&quot;------- LSNonConcurrentOperation exception - %@&quot;, exception);

    } @finally {

    }
}
</code></pre></li>
<li><p><strong>自定义的非并发NSOperation－实现取消操作</strong></p>
<pre><code>- (void)main {
    // 执行之前，检查是否取消Operation
    if (self.isCancelled) return;

    @try {
        NSLog(@&quot;-------- LSNonConcurrentOperation - data:%@, mainThread:%@, currentThread:%@&quot;, self.data, [NSThread mainThread], [NSThread currentThread]);

        // 循环去检测执行逻辑过程中是否取消当前正在执行的Operation
        for (NSInteger i = 0; i &lt; 10000; i++) {

            NSLog(@&quot;run loop -- %@&quot;, @(i + 1));

            if (self.isCancelled) return;
            sleep(1);
        }
        NSLog(@&quot;-------- finish executed %@&quot;, NSStringFromSelector(_cmd));
    } @catch (NSException *exception) {
        NSLog(@&quot;------- LSNonConcurrentOperation exception - %@&quot;, exception);

    } @finally {

    }
}
</code></pre></li>
</ul>
<p><strong>由上可以知道，取消一个任务的执行，其实并不是立即就会取消，而是会在一个runloop中不断的去检查，判断isCancle的值，直到为yes时候，则取消了操作。所以，设置Operation为cancle的时候，至少需要一个runloop的时间才会结束操作。</strong></p>
<h2 id="定制Operation对象的执行行为"><a href="#定制Operation对象的执行行为" class="headerlink" title="定制Operation对象的执行行为"></a>定制Operation对象的执行行为</h2><ul>
<li><strong>修改Operation在队列中的优先级</strong></li>
</ul>
<p><code>NSOperation</code>对象在Queue中可以设置执行任务的优先级。我们可以通过设置operation对象的<code>setQueuePriority:</code>方法，改变任务在队列中的执行优先级。但是真正决定一个operation对象能否执行的是<code>isReady</code>，假设一个operation对象的在队列执行的优先级很高，另一个很低，但是高的operation对象的<code>isReady</code>是NO，也只会执行优先级低的operation任务。另一个影响任务在队列中执行顺序的是依赖(下文会讲到)，假设operation A依赖于operation B，所以一定先执行operation B,再执行operation A.</p>
<ul>
<li><strong>修改Operation执行任务线程的优先级</strong></li>
</ul>
<p>从iOS4.0开始，我们可以设置operation中任务执行的线程优先级。从iOS4.0到iOS8.0，operation对象可以通过方法<code>setThreadPriority:</code>，这里的参数是一个double类型，范围是0.0到1.0，设置越高，理论上讲，线程执行的可能性就越高。但是从iOS8.0之后，这个方法已经被废弃了，使用<code>setQualityOfService:</code>代替，这里参数是一个预设的枚举值。</p>
<ul>
<li><strong>设置Completion Block</strong></li>
</ul>
<p>同上，从iOS4.0开始，可以给每个operation对象设置一个主任务完成之后的完成回调<code>setCompletionBlock:</code>。所设置的block执行是在检测到operation的<code>isFinished</code>为YES后执行的。值得注意的是：<strong>我们并不能保证block所在的线程一定在主线程，所以当我们需要对主线程上做一些操作的时候，我们应该切换线程到主线程中，如需在其他线程执行的某些操作，亦需要切换线程。</strong></p>
<blockquote>
<p>Therefore, you should not use this block to do any work that requires a very specific execution context. Instead, you should shunt that work to your application’s main thread or to the specific thread that is capable of doing it. </p>
</blockquote>
<h2 id="执行Operation对象"><a href="#执行Operation对象" class="headerlink" title="执行Operation对象"></a>执行Operation对象</h2><p>对于执行一个Operation对象，一般的做法是将operation对象添加到一个队列中去，之后队列会根据当前系统的状态，以及内核的状态，自行的去执行operation中的任务。</p>
<pre><code>NSOperationQueue *queue = [[NSOperationQueue alloc] init];
[queue addOperation:opt];
</code></pre><p>还有一种做法是，我们可以手动的执行一个operation对象，直接调用operation的<code>start</code>方法</p>
<pre><code>[opt start];
</code></pre><ul>
<li><strong>添加Operation到Operation Queue中</strong></li>
</ul>
<p>将operation对象添加到queue中非常简单</p>
<p>首先创建一个队列：</p>
<pre><code>NSOperationQueue *queue = [[NSOperationQueue alloc] init];
</code></pre><p>添加到队列的方法如下：</p>
<pre><code>- (void)addOperation:(NSOperation *)op;
- (void)addOperations:(NSArray&lt;NSOperation *&gt; *)ops waitUntilFinished:(BOOL)wait NS_AVAILABLE(10_6, 4_0);
- (void)addOperationWithBlock:(void (^)(void))block NS_AVAILABLE(10_6, 4_0);
</code></pre><p>第一个：添加意境存在的operation对象<br>第二个：添加一组operation对象<br>第三个：直接添加一个block到队列中，无需创建operation对象</p>
<ul>
<li><strong>手动执行Operation</strong></li>
</ul>
<p>一般情况下，我们不需要手动的去执行一个operation对象，但如果需要，亦可，调用<code>start</code>方法。</p>
<pre><code>[opt start];
</code></pre><ul>
<li><strong>取消Operation</strong></li>
</ul>
<p>当我们将一个operation对象添加到队列中之后，operation就已经被队列所拥有。我们可以在某个需要的时候调用operation对象的<code>cancle</code>方法，将operation出列。并且此时operation的<code>isFinished</code>也会为YES，所以此时依赖于它的operation就回继续得到执行。当然，我们可以直接调用队列的<code>cancelAllOperations</code>方法，取消了队列中所有的operation执行。</p>
<ul>
<li><strong>等待Operation执行完成</strong></li>
</ul>
<p>等待一个Operation对象的执行完成，可以使用<code>waitUntilFinished</code>方法。但是应该注意到，等待一个任务执行完，会阻塞当前线程。所以我们绝不应该在主线程中做该操作，那样会带来非常差的体验。所以该操作应该使用辅助线程中。<br>我们也可以调用<code>NSOperationQueue</code>对象的<code>waitUntilAllOperationsAreFinished</code>方法，知道所有的任务都执行完成。</p>
<ul>
<li><strong>暂停和恢复Operation Queue</strong></li>
</ul>
<p>通过设置队列的<code>setSuspended</code>,我们可以暂停一个队列中还没有开始执行的operation对象，对于已经开始的执行的任务，将继续执行。并且，已经暂停了队列，仍然可以继续添加operation对象，但是不会执行，只能等到从暂停(挂起)状态切换到非暂停状态。即设置<code>setSuspended</code>为NO。对于单个的operation，是没有暂停的概念的。</p>
<blockquote>
<p>When the value of this property is NO, the queue actively starts operations that are in the queue and ready to execute. Setting this property to YES prevents the queue from starting any queued operations, but already executing operations continue to execute. You may continue to add operations to a queue that is suspended but those operations are not scheduled for execution until you change this property to NO.</p>
</blockquote>
<h2 id="添加Operation-Queue中Operation对象之间的依赖"><a href="#添加Operation-Queue中Operation对象之间的依赖" class="headerlink" title="添加Operation Queue中Operation对象之间的依赖"></a>添加Operation Queue中Operation对象之间的依赖</h2><p>在<code>NSOperationQueue</code>中，如果没有经过对operation添加依赖，都是使用并发处理的。但是在某些情况下，我们对任务的执行是有非常严格的规定的。即需要串行执行，此时，我们就需要对operation对象间进行添加依赖处理。</p>
<pre><code>- (void)addDependency:(NSOperation *)op;
- (void)removeDependency:(NSOperation *)op;
</code></pre><p>第一个：添加依赖<br>第二个：移除依赖</p>
<p><strong>依赖，是一种非常好用功能，在我们做项目(生活中)的时候，很多时候都一种依赖的概念。比如，用户需要上传一张照片到自己的空间，但是此时必须检测该用户是否已经登录。以前我们可能将两个逻辑写在一起，但是现在可以将成写成两个不同的operation，并设置它们的依赖。这样的好处非常可见的：<br>第一点：它可以帮我们解藕，不同的逻辑分在不一样的对象中。<br>第二点：某些常用的逻辑会经常用到，以后不需要一次次的重复，可读性增强，以后需要的时候直接调用，设置其依赖即可。比如检测是否登录</strong></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>多线程执行任务看似十分的复杂，但是如果将复杂的任务交给<code>NSOperation</code> and <code>NSOperationQueue</code>，就可以简化它的难度，并且它似乎可以比我们自己处理的更好。</p>
<p>文中使用的demo - <a href="https://github.com/beyondverage0908/MyDemo/tree/master/LSOperationAndOperationQueueDemo" target="_blank" rel="noopener">LSOperationAndOperationQueueDemo</a></p>
<h2 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a>感谢</h2><p>以下文章给我带来非常大的帮助</p>
<p><a href="https://laike9m.com/blog/huan-zai-yi-huo-bing-fa-he-bing-xing,61/" target="_blank" rel="noopener">还在疑惑并发和并行？</a><br><a href="http://www.ruanyifeng.com/blog/2013/04/processes_and_threads.html" target="_blank" rel="noopener">进程与线程的一个简单解释</a><br><a href="http://blog.leichunfeng.com/blog/2015/07/29/ios-concurrency-programming-operation-queues/" target="_blank" rel="noopener">iOS 并发编程之 Operation Queues</a><br><a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/NSOperationQueue_class/" target="_blank" rel="noopener">NSOperationQueue - 文档</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/12/blog-3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="mdiep">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mdiep">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/12/blog-3/" itemprop="url">Method Swizzling的实践 - 实现页面的统计功能</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-04-12T10:18:22+08:00">
                2018-04-12
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS/" itemprop="url" rel="index">
                    <span itemprop="name">iOS</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS/Runtime/" itemprop="url" rel="index">
                    <span itemprop="name">Runtime</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/04/12/blog-3/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2018/04/12/blog-3/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <pre><code>#import &lt;objc/runtime.h&gt;
</code></pre><blockquote>
<p>在OC中，最具争议的语法，莫过于<code>runtime</code>中的运行时的语法。而其中黑魔法Method Swizzling更让人着迷。</p>
</blockquote>
<p>Method Swizzling是一项在运行时，通过改变方法名(SEL)与函数指针之间的映射。从而改变方法实现的黑魔法技术。如下图。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1626952-940656a52c93368a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Method Swizzling模型图.png"></p>
<h3 id="场景需求"><a href="#场景需求" class="headerlink" title="场景需求"></a>场景需求</h3><blockquote>
<p>实践是检验真理的唯一标准 - 继续</p>
</blockquote>
<p>能否快速而可靠的学习到某个技术点，最好的方法，还是找到一个场景，去实现它。项目中，我们经常会有这样的需求，去统计用户每一个页面的访问量，什么时候页面出现，什么时候页面消失。由此获取来的数据，去判断用户黏性，功能点的使用情况的等。对于统计的功能，我们可以交给第三方的厂商，比如百度统计，友盟等。</p>
<p>但是，我们最少需要告诉第三方厂商的库，现在是用户打开了这个页面。现在是用户关闭了这个页面。之前的做法是，在每一个Controller的<code>- viewDidAppear:</code>中调用一个用户开始使用的方法。在<code>- viewDidDisappear</code>中调用一个用户结束使用的方法。OK了，这个需求解决了。但是随着项目的的增大，发现每一个Controller中都需要写两个一摸一样的方法。这样违背了软件开发的开发准则—“一个方法只写一遍”。</p>
<p>幸好的是，在学习微信阅读开源的一款内存检测工具<a href="https://github.com/Zepo/MLeaksFinder" target="_blank" rel="noopener">MLeaksFinder</a>。其中的代码零侵染，易用性，很好的在开发中帮助我解决了一些内存泄露的问题。而从源码中，MLeaksFinder就是利用了Method Swizzling技术。受该框架启发，也希望实现对代码侵染程度小，却可以很好的实现统计的功能。</p>
<h3 id="Method-Swizzling实现"><a href="#Method-Swizzling实现" class="headerlink" title="Method Swizzling实现"></a>Method Swizzling实现</h3><pre><code>+ (void)load {
    static dispatch_once_t onceToken;
    dispatch_once(&amp;onceToken, ^{
        [self swizzleSEL:@selector(viewDidAppear:) withSEL:@selector(swizzled_viewDidAppear:)];
        [self swizzleSEL:@selector(viewDidDisappear:) withSEL:@selector(swizzled_viewDidDisappear:)];
    });
}

/// 交换两个方法的实现
+ (void)swizzleSEL:(SEL)originalSEL withSEL:(SEL)swizzledSEL {
    Class class = [self class];

    Method originalMethod = class_getInstanceMethod(class, originalSEL);
    Method swizzledMethod = class_getInstanceMethod(class, swizzledSEL);

    // When swizzling a class method, use the following:
    // Class class = object_getClass((id)self);
    // ...
    // Method originalMethod = class_getClassMethod(class, originalSelector);
    // Method swizzledMethod = class_getClassMethod(class, swizzledSelector);

    BOOL didAddMethod = class_addMethod(class, originalSEL, method_getImplementation(swizzledMethod), method_getTypeEncoding(swizzledMethod));

    if (didAddMethod) {
        class_replaceMethod(class, swizzledSEL, method_getImplementation(originalMethod), method_getTypeEncoding(originalMethod));
    } else {
        method_exchangeImplementations(originalMethod, swizzledMethod);
    }
}

#pragma mark - Swizzled Method

- (void)swizzled_viewDidAppear:(BOOL)animated {
    [self swizzled_viewDidAppear:animated];
}

- (void)swizzled_viewDidDisappear:(BOOL)animated {
    [self swizzled_viewDidDisappear:animated];
}
</code></pre><p>上面的代码，便已经实现了<code>- viewDidAppear:</code>和<code>- swizzled_viewDidAppear:</code>方法实现的互换。如果仅仅是拷贝和黏贴，这样已经实现了功能。想要更深的了解运行时的工作机制。还需要了解这部分内容。</p>
<h4 id="void-load-amp-void-initialize"><a href="#void-load-amp-void-initialize" class="headerlink" title="+ (void)load; &amp; + (void)initialize;"></a>+ (void)load; &amp; + (void)initialize;</h4><p>load方法和initialize方法都是可选方法。load方法在类初装载的时候被调用，即load方法一定被调用。Method Swizzling同样应该在load方法实现。initailize方法仅在类的实例方法或者类方法第一次调用的时候调用。</p>
<h4 id="dispatch-once"><a href="#dispatch-once" class="headerlink" title="dispatch_once"></a>dispatch_once</h4><p>由于Method Swizzling触发是全局范围内的。必须保证只触发一次，并且是原子性的，在多线程间也仅仅调用一次。GCD中的dispatch_once很好的符合了要求。同样的，在OC中的单利对象的标准也应该使用这种方式。</p>
<h4 id="SEL，Method，IMP"><a href="#SEL，Method，IMP" class="headerlink" title="SEL，Method，IMP"></a>SEL，Method，IMP</h4><blockquote>
<p>Selector（typedef struct objc_selector *SEL）:在运行时 Selectors 用来代表一个方法的名字。Selector 是一个在运行时被注册（或映射）的C类型字符串。Selector由编译器产生并且在当类被加载进内存时由运行时自动进行名字和实现的映射。</p>
<p>Method（typedef struct objc_method *Method）:方法是一个不透明的用来代表一个方法的定义的类型。</p>
<p>Implementation（typedef id (*IMP)(id, SEL,…)）:这个数据类型指向一个方法的实现的最开始的地方。该方法为当前CPU架构使用标准的C方法调用来实现。该方法的第一个参数指向调用方法的自身（即内存中类的实例对象，若是调用类方法，该指针则是指向元类对象metaclass）。第二个参数是这个方法的名字selector，该方法的真正参数紧随其后。</p>
</blockquote>
<h4 id="说说Method-Swizzling工作过程"><a href="#说说Method-Swizzling工作过程" class="headerlink" title="说说Method Swizzling工作过程"></a>说说Method Swizzling工作过程</h4><p>在类初始化，初次装载的时候，执行load方法。找到类维护的方法(包含方法名SEL和映射的实现IMP)列表，修改selector(方法名)和imp(实现体)的映射关系。因此当系统调用系统方法时候，其实调用的是我们自定义的方法。</p>
<h4 id="看似错误的代码"><a href="#看似错误的代码" class="headerlink" title="看似错误的代码"></a>看似错误的代码</h4><pre><code>- (void)swizzled_viewDidAppear:(BOOL)animated {
    [self swizzled_viewDidAppear:animated];
}
</code></pre><p>如上，这段代码，对于一个合格的工程师而言，应该会很警惕。正常情况下在类中调用，必然进入无限循环。然而，在Method Swizzling中，这样才是正确的用法。理解下其中的逻辑。在load方法中实现了Swizzling，系统SEL的<code>viewDidAppear</code>指向的是<code>swizzled_viewDidAppear</code>的实现，方法SEL名为<code>swizzled_viewDidAppear</code>指向的是系统名为<code>viewDidAppear</code>的实现。所以在调用过程中相当两个方法交叉调用了，并没有导致死循环。</p>
<h3 id="最后-百度统计逻辑业务代码的实现"><a href="#最后-百度统计逻辑业务代码的实现" class="headerlink" title="最后-百度统计逻辑业务代码的实现"></a>最后-百度统计逻辑业务代码的实现</h3><pre><code>#pragma mark - Method Swizzling

- (void)swizzled_viewDidAppear:(BOOL)animated {
    [self swizzled_viewDidAppear:animated];

    NSString *currentControllerTitle = self.title;
    if (!currentControllerTitle) return;

    [[BaiduMobStat defaultStat] pageviewStartWithName:currentControllerTitle];
}

- (void)swizzled_viewDidDisappear:(BOOL)animated {
    [self swizzled_viewDidDisappear:animated];

    NSString *currentControllerTitle = self.title;
    if (!currentControllerTitle) return;

    [[BaiduMobStat defaultStat] pageviewEndWithName:currentControllerTitle];
}
</code></pre><p>统计的代码仅仅几行而已，只需要放在<code>UIControllerView+Traking.m</code>类别中。不仅减少了项目无关业务逻辑的代码量，同样做到了代码的侵染度很少。</p>
<h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><p>引自NSHipster</p>
<blockquote>
<p>很多人认为交换方法实现会带来无法预料的结果。然而采取了以下预防措施后, method swizzling 会变得很可靠：</p>
</blockquote>
<blockquote>
<ul>
<li>在交换方法实现后记得要调用原生方法的实现（除非你非常确定可以不用调用原生方法的实现）：APIs 提供了输入输出的规则，而在输入输出中间的方法实现就是一个看不见的黑盒。交换了方法实现并且一些回调方法不会调用原生方法的实现这可能会造成底层实现的崩溃。</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>避免冲突：为分类的方法加前缀，一定要确保调用了原生方法的所有地方不会因为你交换了方法的实现而出现意想不到的结果。</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>理解实现原理：只是简单的拷贝粘贴交换方法实现的代码而不去理解实现原理不仅会让 App 很脆弱，并且浪费了学习 Objective-C 运行时的机会。阅读 Objective-C Runtime Reference 并且浏览 能够让你更好理解实现原理。</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>持续的预防：不管你对你理解 swlzzling 框架，UIKit 或者其他内嵌框架有多自信，一定要记住所有东西在下一个发行版本都可能变得不再好使。做好准备，在使用这个黑魔法中走得更远，不要让程序反而出现不可思议的行为。</li>
</ul>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/12/blog-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="mdiep">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mdiep">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/12/blog-2/" itemprop="url">关于使用WKWebView时，ViewController不调用dealloc方法的记录</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-04-12T09:44:02+08:00">
                2018-04-12
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS/" itemprop="url" rel="index">
                    <span itemprop="name">iOS</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS/WebView/" itemprop="url" rel="index">
                    <span itemprop="name">WebView</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/04/12/blog-2/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2018/04/12/blog-2/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在当前的项目中，会嵌入很多的H5页面，所以就考虑封装一个Controller，用于完全的显示H5页面。基于当前项目对iOS版本的支持在iOS8.0之上，所以选用<code>WKWebView</code>。</p>
<p>很正常的在<code>ViewDidLoad</code>中初始化，设置<code>WKWebView</code></p>
<pre><code>- (void)setupWKWebView {
    WKWebViewConfiguration *configuration = [[WKWebViewConfiguration alloc] init];
    WKUserContentController *controller = [[WKUserContentController alloc] init];
    configuration.userContentController = controller;
    self.contentWKWebView = [[WKWebView alloc] initWithFrame:CGRectMake(0, 64, SCREENW, SCREENH - NAVIAGTION_HEIGHT)
                                           configuration:configuration];
    self.contentWKWebView.UIDelegate = self;
    self.contentWKWebView.navigationDelegate = self;
    self.contentWKWebView.allowsBackForwardNavigationGestures = YES;
    // 监听进度条
    [self.contentWKWebView addObserver:self
                        forKeyPath:@&quot;estimatedProgress&quot;
                           options:NSKeyValueObservingOptionNew context:nil];

    // 注册JS交互对象
    WKUserContentController *controller = self.contentWKWebView.configuration.userContentController;
    [controller addScriptMessageHandler:self name:@&quot;vhswebview&quot;];
}
</code></pre><p>然后加载H5页面，一切看着都很正常，但是经过多次测试，发现对应的<code>- (void)dealloc;</code>一次都没有调用，所以必然出现了内存泄漏。检查该<code>Controller</code>代码，发现诸如block的循环引用，代理等地方都没有问题。</p>
<p>最后猜测是否是注册JS交互对象的时候，将对象本身<code>self</code>传给<code>MessageHandler</code>导致的。后面查询了一些资料，发现在Apple的development中提到了需要移除JS交互对象<code>removeScriptMessageHandlerForName</code>。</p>
<p>所以将页面关闭<code>WKWebView</code>的<code>Controller</code>的时候，就去移除JS交互对象</p>
<pre><code>WKUserContentController *controller = self.contentWKWebView.configuration.userContentController;
[controller removeScriptMessageHandlerForName:@&quot;vhswebview&quot;];
</code></pre><p>最后，就可以在关闭页面后调用<code>dealloc</code>了。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/04/11/blog-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="mdiep">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mdiep">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/04/11/blog-1/" itemprop="url">结合RSA，AES128，MD5---移动端与服务端在通信层的加密处理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-04-11T23:36:04+08:00">
                2017-04-11
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS/" itemprop="url" rel="index">
                    <span itemprop="name">iOS</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS/加密/" itemprop="url" rel="index">
                    <span itemprop="name">加密</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/04/11/blog-1/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2017/04/11/blog-1/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>很高兴能在项目中使用到RSA，AES128，以及MD5，用以保证客户端(Client)和服务端(Server)之间的通信安全。接下来会尽力的描述清楚关于本次使用的流程。具体关于算法的细节，自行Wiki。</p>
</blockquote>
<blockquote>
<p>原来只是对加密这一块很简单的了解，比如只知道一些对称加密，非对称加密，md5单向加密等。通过本次的学习，很惊艳于可以将多种加密方式那么完美的结合到一起。让整个通信过程变得如此美妙。虽然增加了服务端和客户端的工作量，但是保证数据的一致出口，一致入口，只需要在出口和入口处加上逻辑，就可以很好的避免扰乱原有逻辑的烦恼。</p>
</blockquote>
<h2 id="简单的概念，文章可能会涉及到"><a href="#简单的概念，文章可能会涉及到" class="headerlink" title="简单的概念，文章可能会涉及到"></a>简单的概念，文章可能会涉及到</h2><ol>
<li>RSA——非对称加密，会产生公钥和私钥，公钥在客户端，私钥在服务端。公钥用于加密，私钥用于解密。</li>
<li>AES——对称加密，直接使用给定的秘钥加密，使用给定的秘钥解密。(加密解密使用相同的秘钥)</li>
<li>MD5——一种单向的加密方式，只能加密，不能解密</li>
<li>Base64编码——对字节数组转换成字符串的一种编码方式</li>
</ol>
<h2 id="客户端，服务端的通信逻辑"><a href="#客户端，服务端的通信逻辑" class="headerlink" title="客户端，服务端的通信逻辑"></a>客户端，服务端的通信逻辑</h2><p><strong>之前：明文传输通信</strong></p>
<ol>
<li>客户端将要上传的数据以字典(Map)的方式打包，Post提交给服务器。</li>
<li>服务器接收提交的数据包，通过Key-Value的形式获取客户端提交的值，进行处理。</li>
<li>处理结束，将数据以字典(Map)的形式打包，返回给客户端处理。</li>
</ol>
<p><strong>加密传输通信</strong></p>
<p>整个流程是：</p>
<p><strong>客户端上传数据加密</strong> ==&gt; <strong>服务器获取数据解密</strong> ==&gt; <strong>服务器返回数据加密</strong> ==&gt; <strong>客户端获取数据解密</strong></p>
<ul>
<li><p>客户端上传数据加密 A</p>
<ol>
<li>客户端随机产生一个16位的字符串，用以之后AES加密的秘钥，AESKey。</li>
<li>使用RSA对AESKey进行公钥加密，RSAKey</li>
<li>(此处某些重要的接口需要加签处理，后续讲解，不要加签处理的省略该步骤)</li>
<li>将明文的要上传的数据包(字典/Map)转为Json字符串，使用AESKey加密，得到JsonAESEncryptedData。</li>
<li>封装为{key : RSAKey, value : JsonAESEncryptedData}的字典上传服务器，服务器只需要通过key和value，然后解析，获取数据即可。</li>
</ol>
</li>
<li><p>服务器获取数据解密 B</p>
<ol>
<li>获取到RSAKey后用服务器私钥解密，获取到AESKey</li>
<li>获取到JsonAESEncriptedData，使用AESKey解密，得到明文的客户端上传上来的数据。</li>
<li>(如果客户端进行了加签处理，此处需要验签，以保证数据在网络传输过程中是否被篡改)</li>
</ol>
</li>
<li><p>服务器返回数据加密 C</p>
<ol>
<li>将要返回给客户端的数据(字典/Map)转成Json字符串，用AESKey加密处理</li>
<li>(此处也可以加签处理)</li>
<li>封装数据{data : value}的形式返回给客户端</li>
</ol>
</li>
<li><p>客户端获取数据解密 D</p>
<ol>
<li>客户端获取到数据后通过key为data得到服务器返回的已经加密的数据AESEncryptedResponseData</li>
<li>对AESEncryptedResponseData使用AESKey进行解密，得到明文服务器返回的数据。</li>
</ol>
</li>
</ul>
<h2 id="加签和验签"><a href="#加签和验签" class="headerlink" title="加签和验签"></a>加签和验签</h2><blockquote>
<p>第二节——<strong>“客户端，服务端的通信逻辑”</strong>已经基本上把客户端和服务端的通信加密逻辑讲完了。至于<strong>“加签和验签”</strong>主要是针对数据传输过程中，防止数据被篡改的一种做法。</p>
</blockquote>
<p>数据被篡改，栗子：</p>
<p>对于一个运动类型的APP，上传运动的步数，是一个常见的接口操作。比如该接口会有几个字段，step(步数)，time(步数产生的时间)，memberId(用户id)。</p>
<p>假设某用户抓取了你上传的数据包，然后成功的破解了你之前的加密方式。得到对应的明文，此时该用户就可以随意修改你的数据，比如step，然后以相同的方式加密，post到你的服务器，此时服务器会认为这是一次正常的请求，便接受了这个修改后的步数。其实此时的数据是错误的。如此神不知鬼不觉。。。</p>
<p>为了防止这种做法，我们可以是加签的处理方式</p>
<ul>
<li><p>加签处理(数据发起方都可以加签，此处是客户端)</p>
<ol>
<li>我们一般取其中的关键字段(别人可能修改的字段)，比如此时step，和time及memberId，都比较敏感。</li>
<li>在上文的A中的第二步之后，获取step，time，memberId，拼接成一个字符串(顺序和服务器约定好)，然后使用md5加密，采用base64编码(编码格式和服务约定)。得到signData</li>
<li>然后将获取到的signData以key-value的形式保存到原来明文的数据包中，然后进行A的第三步</li>
</ol>
</li>
<li><p>验签处理(数据接受方都可以验签，此处服务端)</p>
<ol>
<li>如上，到B的第三步，此时已经得到了客户端上传的明文数据</li>
<li>按照喝客户端约定的字段拼接，将得到的step，time，memberId拼接后，使用同样的md5_base64处理，然后比较数据包中的签名sign是否和客户端当时的签名一致。</li>
<li>如果一致，接受数据。不一致，抛弃数据，终止本次操作</li>
</ol>
</li>
</ul>
<blockquote>
<p>假设加签之后的数据包被截获，然后解密成功，得到明文的数据包。但是签名md5加密是无法解密的(单向加密)。此时即时修改了step，然后post到服务器，服务器通过修改后的step，time，memberId得到的字符串经过md5加密后，一定会与客户端的签名不一致。从而数据被抛弃。</p>
</blockquote>
<h2 id="流程图描述上文"><a href="#流程图描述上文" class="headerlink" title="流程图描述上文"></a>流程图描述上文</h2><p><img src="http://upload-images.jianshu.io/upload_images/1626952-b9991bb49d2f4f42.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="客户端服务端通信加密逻辑.png"></p>
<h2 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h2><p>关于AES，和RSA加密解密，只能出iOS端的代码。关于如何在Linux下生成RSA公钥和私钥证书，参照<a href="http://www.jianshu.com/p/bfa57e049a7e" target="_blank" rel="noopener">RSA公钥、私钥生成，详细讲解</a>，网上很多</p>
<p><a href="https://github.com/beyondverage0908/CAAdvancedTech" target="_blank" rel="noopener">github的demo地址–CAAdvancedTech</a></p>
<p>运行，如下入显示</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1626952-d672dbe8b91fa7ed.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="首页选择加密模块"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1626952-103e1ca8ed1d8540.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="AES，RSA加密解密页面"></p>
<h2 id="RSA公钥-生成自签名证书"><a href="#RSA公钥-生成自签名证书" class="headerlink" title="RSA公钥-生成自签名证书"></a>RSA公钥-生成自签名证书</h2><pre><code>// 生成1024位私钥
openssl genrsa -out private_key.pem 1024

// 根据私钥生成CSR文件
openssl req -new -key private_key.pem -out rsaCertReq.csr

// 根据私钥和CSR文件生成crt文件
openssl x509 -req -days 3650 -in rsaCertReq.csr -signkey private_key.pem -out rsaCert.crt

// 为IOS端生成公钥der文件
openssl x509 -outform der -in rsaCert.crt -out public_key.der

// 将私钥导出为这p12文件
openssl pkcs12 -export -out private_key.p12 -inkey private_key.pem -in rsaCert.crt
</code></pre><p>参照 <a href="http://www.jianshu.com/p/51bb0ad0b113" target="_blank" rel="noopener">漫谈RSA非对称加密解密</a></p>
<h2 id="推荐工具"><a href="#推荐工具" class="headerlink" title="推荐工具"></a>推荐工具</h2><ol>
<li><p>关于画流程图</p>
<p> 之前一致比较苦扰在Mac上有哪一款好用的可以画流程图，UML的工具，甚至都考虑过Keynote。最后发现这款在线的工具很不错，上图就是使用这款工具，第一次画的。效果不错。就是导出png图片分辨率不是很好</p>
<p> <a href="http://www.processon.com/" target="_blank" rel="noopener">工具processOn</a></p>
<p> <a href="https://www.zhihu.com/question/19588698" target="_blank" rel="noopener">Mac 上最好用的流程图软件是什么？</a></p>
</li>
<li><p>关于AES加密解密在线工具</p>
<p> <a href="http://www.seacha.com/tools/aes.html?src=kjwfNbM%2B%2BAKaIF8%2BbMMKdQ%3D%3D&amp;mode=CBC&amp;keylen=128&amp;key=1111&amp;iv=&amp;bpkcs=&amp;session=MCRm2Ac3VV2CGGBaWu00&amp;aes=e006c1c0738be822b222bc4d2603a82a&amp;encoding=base64&amp;type=1" target="_blank" rel="noopener">在线AES加解密</a></p>
</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/01/01/myself/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="mdiep">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mdiep">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/01/01/myself/" itemprop="url">我的简历</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-01-01T17:13:30+08:00">
                2017-01-01
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/01/01/myself/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2017/01/01/myself/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="联系方式"><a href="#联系方式" class="headerlink" title="联系方式"></a>联系方式</h1><ul>
<li>手机：18516133629</li>
<li>Email：<a href="mailto:beyondaverage0908@gmail.com" target="_blank" rel="noopener">beyondaverage0908@gmail.com</a></li>
<li>QQ/微信号：605320322</li>
</ul>
<hr>
<h1 id="个人信息"><a href="#个人信息" class="headerlink" title="个人信息"></a>个人信息</h1><ul>
<li>林平君，男，1992年生 </li>
<li>本科经历：南昌航空大学，软件工程专业，15年毕业，CET4</li>
<li>工作年限：3年</li>
<li>技术博客：<a href="https://www.jianshu.com/u/657a7c77e675" target="_blank" rel="noopener">https://www.jianshu.com/u/657a7c77e675</a></li>
<li>Github：<a href="https://github.com/beyondverage0908" target="_blank" rel="noopener">https://github.com/beyondverage0908</a></li>
<li>期望职位：iOS开发工程师</li>
<li>期望薪资：16k~20k，特别喜欢的公司可例外</li>
<li>期望城市：上海</li>
</ul>
<hr>
<h1 id="工作经历"><a href="#工作经历" class="headerlink" title="工作经历"></a>工作经历</h1><h3 id="好人生健康科技有限公司-2016-07-至今"><a href="#好人生健康科技有限公司-2016-07-至今" class="headerlink" title="好人生健康科技有限公司 (2016.07-至今)"></a>好人生健康科技有限公司 (2016.07-至今)</h3><ul>
<li><strong>2016.7 - 2017.6：</strong> iOS负责人（原团队2人，后团队1人，另一人离职）</li>
<li><strong>2017.6 - 至今：</strong> iOS负责人 兼 前端工程师</li>
</ul>
<h3 id="上海慷慷汇科技有限公司-2015-1-2016-6"><a href="#上海慷慷汇科技有限公司-2015-1-2016-6" class="headerlink" title="上海慷慷汇科技有限公司 (2015.1-2016.6)"></a>上海慷慷汇科技有限公司 (2015.1-2016.6)</h3><ul>
<li><strong>2015.1 - 2015.6</strong> iOS开发实习生</li>
<li><strong>2015.6 - 2016.6</strong> iOS开发工程师</li>
</ul>
<h2 id="项目经历"><a href="#项目经历" class="headerlink" title="项目经历"></a>项目经历</h2><h3 id="好人生科技有限公司-2016-7-至今"><a href="#好人生科技有限公司-2016-7-至今" class="headerlink" title="好人生科技有限公司(2016.7-至今)"></a>好人生科技有限公司(2016.7-至今)</h3><p>主要开发，维护项目包括——V健康Plus，跃动申能，快乐东方，健康交行，V健康</p>
<h4 id="1-V健康Plus"><a href="#1-V健康Plus" class="headerlink" title="1. V健康Plus"></a>1. V健康Plus</h4><p>项目语言OC/Swift混编，项目特点（难点 or 技术点）</p>
<ol>
<li>多target (单个工程，输入如V健康Plus、跃动申能、<a href="https://moa1.orientsec.com.cn/dfzqUpload/app/kldf.html" target="_blank" rel="noopener">快乐东方企业版</a>(In-House)等三个target)</li>
<li>网络数据传输结合RSA和AES加密使用（我梳理了整套加密流程<a href="https://www.jianshu.com/p/b092b4fac27c" target="_blank" rel="noopener">结合RSA，AES128，MD5—移动端与服务端在通信层的加密处理</a>）</li>
<li>离线操作，数据本地化，设备间同步数据，数据关键字段AES128加密</li>
<li>统计业务和主业务(Controller)分离（我梳理主要思想与实现<a href="https://www.jianshu.com/p/e78c98b2d2a6" target="_blank" rel="noopener">Method Swizzling - 统计功能</a>）</li>
<li>利用CoreMotion框架实现实时记录运动信息</li>
<li>WKWebView实现Native和JS通信<a href="https://www.jianshu.com/p/cd210711d3bd" target="_blank" rel="noopener">关于使用WKWebView时，ViewController不调用dealloc方法的记录</a></li>
<li>实现列表图片懒加载（滑动不加载图片，停止即加载，使列表更加流畅）</li>
</ol>
<h3 id="上海慷慷汇科技有限公司-2015-1-2016-6-1"><a href="#上海慷慷汇科技有限公司-2015-1-2016-6-1" class="headerlink" title="上海慷慷汇科技有限公司(2015.1-2016.6)"></a>上海慷慷汇科技有限公司(2015.1-2016.6)</h3><p>主要开发，维护项目 —— 青苹果健康普通版，青苹果健康医生版</p>
<h4 id="1-青苹果健康普通版，青苹果健康医生版"><a href="#1-青苹果健康普通版，青苹果健康医生版" class="headerlink" title="1. 青苹果健康普通版，青苹果健康医生版"></a>1. 青苹果健康普通版，青苹果健康医生版</h4><p>项目语言OC/Swift混编，项目特点（难点 or 技术点）</p>
<ol>
<li>多Storyboard开发视图</li>
<li>内存优化和列表流畅性</li>
<li>openUrl方式实现组件化</li>
<li>下载中心模块，文件的断点续传下载</li>
<li>UI性能调试及调优 <a href="https://www.jianshu.com/p/3656ef4143da" target="_blank" rel="noopener">我记录了——UI性能调试及调优</a></li>
</ol>
<h3 id="其他项目"><a href="#其他项目" class="headerlink" title="其他项目"></a>其他项目</h3><h4 id="1-V健康Plus小程序"><a href="#1-V健康Plus小程序" class="headerlink" title="1. V健康Plus小程序"></a>1. V健康Plus小程序</h4><p>由于公司(好人生科技有限公司)的业务扩展，需要在微信端支持业务，所以从客户端转向微信小程序。由此也学习前端知识，负责【V健康Plus】小程序的开发，已独立开发完成第一个版本。</p>
<h4 id="2-保险公司微信端公众号增值服务——前端项目"><a href="#2-保险公司微信端公众号增值服务——前端项目" class="headerlink" title="2. 保险公司微信端公众号增值服务——前端项目"></a>2. 保险公司微信端公众号增值服务——前端项目</h4><p>由于公司(好人生科技有限公司)和多家保险公司有合作，需要对保险公司提供增值服务。所以开发了如”体检指标”，”心理测评”，”生理测评”，”智能预诊”，”健康咨询”等多个模块。现已经上线到中宏保险，泰康保险，中德安联等多个保险平台。</p>
<hr>
<h1 id="开源项目和作品"><a href="#开源项目和作品" class="headerlink" title="开源项目和作品"></a>开源项目和作品</h1><h2 id="开源项目"><a href="#开源项目" class="headerlink" title="开源项目"></a>开源项目</h2><ul>
<li><a href="https://github.com/beyondverage0908/LoopTimer" target="_blank" rel="noopener">LoopTimer</a>：1. 基于GCD实现的一个定时器 2. 不依赖于NSRunLoop 3. 不会产生循环引用 4. 支持GCD queue，在其他线程重执行任务 5. 支持closure语法执行</li>
<li><a href="https://github.com/beyondverage0908/MKDateFormatterFactory" target="_blank" rel="noopener">MKDateFormatterFactory</a>：1. 工厂单利类创建DateFormatter对象 2. 缓存DateFormatter对象，减少创建对象开销 3. 提供了对时间格式化自定义格式，和系统格式。</li>
</ul>
<h2 id="技术文章"><a href="#技术文章" class="headerlink" title="技术文章"></a>技术文章</h2><p>我的博客地址<a href="https://www.jianshu.com/u/657a7c77e675" target="_blank" rel="noopener">我的博客</a></p>
<ul>
<li><a href="https://www.jianshu.com/p/b092b4fac27c" target="_blank" rel="noopener">结合RSA，AES128，MD5—移动端与服务端在通信层的加密处理</a></li>
</ul>
<h1 id="技能清单"><a href="#技能清单" class="headerlink" title="技能清单"></a>技能清单</h1><p>以下均为我熟悉使用的技能</p>
<ul>
<li>客户端iOS开发：Objective-C/Xcode/Swift</li>
<li>前端开发：HTML/JavaScript/CSS/Vue.js/IDEA</li>
<li>抓包网络调试工具：Charles</li>
<li>数据库相关：SQLite/MySQL</li>
<li>协作管理：Git/Svn</li>
<li>终端：zsh</li>
</ul>
<h1 id="致谢"><a href="#致谢" class="headerlink" title="致谢"></a>致谢</h1><p>感谢您花时间阅读我的简历，期待能有机会和您共事。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">mdiep</p>
              <p class="site-description motion-element" itemprop="description">好人生科技有限公司，主职iOS开发，和H5开发的软件开发工程师</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">7</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">7</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">13</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/beyondverage0908" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:beyondaverage0908@gmail.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://www.jianshu.com/u/657a7c77e675" target="_blank" title="简书">
                      
                        <i class="fa fa-fw fa-globe"></i>简书</a>
                  </span>
                
            </div>
          

          
          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-block">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                Links
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="https://www.jianshu.com/u/657a7c77e675" title="mdiep的简书" target="_blank">mdiep的简书</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://nonomori.farbox.com/" title="Nonomori" target="_blank">Nonomori</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://blog.ibireme.com/" title="ibireme" target="_blank">ibireme</a>
                  </li>
                
              </ul>
            </div>
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2015 &mdash; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">mdiep</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  










  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src="//unpkg.com/valine/dist/Valine.min.js"></script>
  
  <script type="text/javascript">
    var GUEST = ['nick','mail','link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item=>{
      return GUEST.indexOf(item)>-1;
    });
    new Valine({
        el: '#comments' ,
        verify: false,
        notify: false,
        appId: 'm5m9e42n1FYqbouKwYXAAy2A-gzGzoHsz',
        appKey: 'UFW7oCdLac4ISbyo2gwfahav',
        placeholder: 'ヾﾉ≧∀≦)o 来呀！快活呀！~',
        avatar:'mm',
        guest_info:guest,
        pageSize:'10' || 10,
    });
  </script>



  





  

  

  

  
  

  

  

  

</body>
</html>
